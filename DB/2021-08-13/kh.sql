SET SERVEROUTPUT ON;

-- 반복문1 : 조건없이 무한반복

DECLARE
    NUM NUMBER := 1;
BEGIN
    LOOP
        DBMS_OUTPUT.PUT_LINE(NUM);
        NUM := NUM + 1;
        IF NUM > 5 
            THEN EXIT;
        END IF;
    END LOOP;
END;
/


-- 반복문2 : FOR LOOP

DECLARE

BEGIN
    FOR NUM IN 1..5 LOOP
        DBMS_OUTPUT.PUT_LINE(NUM);
    END LOOP;
END;
/


DECLARE

BEGIN
    FOR NUM IN REVERSE 1..5 LOOP
        DBMS_OUTPUT.PUT_LINE(NUM);
    END LOOP;
END;
/


DECLARE
    NAME        EMP_COPY.EMP_NAME%TYPE;
    D_TITLE     EMP_COPY.DEPT_TITLE%TYPE; 
BEGIN
    FOR NUM IN 0..4 LOOP
    SELECT EMP_NAME, DEPT_TITLE
    INTO NAME, D_TITLE
    FROM EMP_COPY
    WHERE EMP_ID = 200 + NUM;
    
    DBMS_OUTPUT.PUT_LINE('이름 : ' || NAME);
    DBMS_OUTPUT.PUT_LINE('부서명 : ' || D_TITLE);
    END LOOP;
END;
/


DECLARE
    ID          EMPLOYEE.EMP_ID%TYPE;
    NAME        EMPLOYEE.EMP_NAME%TYPE;
    D_TITLE     DEPARTMENT.DEPT_TITLE%TYPE;
    J_NAME      JOB.JOB_NAME%TYPE;
    SAL         EMPLOYEE.SALARY%TYPE;
BEGIN
    FOR NUM IN 0..4 LOOP
        SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY
        INTO ID, NAME, D_TITLE, J_NAME, SAL
        FROM EMPLOYEE
        LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
        LEFT JOIN JOB USING (JOB_CODE)
        WHERE EMP_ID = 200 + NUM;
        INSERT INTO EMP_COPY VALUES (ID, NAME, D_TITLE, J_NAME, SAL); 
    END LOOP;
END;
/

SELECT * FROM EMP_COPY ORDER BY 1;




-- TOP  N 분석
-- 급여 / 보너스 / 일사일 중 하나를 입력하면 해당하는 기준으로 1 ~ 5위 출력

SELECT ROWNUM, E. * FROM (SELECT EMP_NAME, SALARY FROM EMPLOYEE ORDER BY SALARY DESC) E;

SELECT * FROM (SELECT ROWNUM AS RNUM, E. * FROM (SELECT EMP_NAME, SALARY FROM EMPLOYEE ORDER BY SALARY DESC) E)
WHERE RNUM = 2;

SELECT * FROM (SELECT ROWNUM AS RNUM, E. * FROM (SELECT EMP_NAME, NVL(BONUS, 0) FROM EMPLOYEE ORDER BY 2 DESC) E)
WHERE RNUM = 2;

SELECT * FROM (SELECT ROWNUM AS RNUM, E. * FROM (SELECT EMP_NAME, HIRE_DATE FROM EMPLOYEE ORDER BY 2) E)
WHERE RNUM = 2;



DECLARE
    KEYWORD     VARCHAR2(10);
    RANKING     NUMBER;
    NAME        EMPLOYEE.EMP_NAME%TYPE;
    SAL         EMPLOYEE.SALARY%TYPE;
    BO          EMPLOYEE.BONUS%TYPE;
    H_DATE      EMPLOYEE.HIRE_DATE%TYPE;
BEGIN
    KEYWORD := '&키워드';
    CASE KEYWORD
        WHEN '급여' THEN
            DBMS_OUTPUT.PUT_LINE('--------- 급여 랭킹 TOP 5 ---------');
            FOR NUM IN 1..5 LOOP
                SELECT *
                INTO RANKING, NAME, SAL
                FROM (SELECT ROWNUM AS RNUM, E. * FROM (SELECT EMP_NAME, SALARY FROM EMPLOYEE ORDER BY SALARY DESC)E)
                WHERE RNUM = NUM;
                DBMS_OUTPUT.PUT_LINE('랭킹 : ' || RANKING || ' / 이름 : '|| NAME || ' / 급여 : ' || SAL);
            END LOOP;
        WHEN '보너스' THEN
            DBMS_OUTPUT.PUT_LINE('--------- 보너스 랭킹 TOP 5 ---------');
            FOR NUM IN 1..5 LOOP
                SELECT *
                INTO RANKING, NAME, BO
                FROM (SELECT ROWNUM AS RNUM, E. * FROM (SELECT EMP_NAME, NVL(BONUS, 0) FROM EMPLOYEE ORDER BY 2 DESC)E)
                WHERE RNUM = NUM;
                DBMS_OUTPUT.PUT_LINE('랭킹 : ' || RANKING || ' / 이름 : '|| NAME || ' / 보너스 : ' || BO);
            END LOOP;
        WHEN '입사일' THEN
            DBMS_OUTPUT.PUT_LINE('--------- 입사일 랭킹 TOP 5 ---------');
            FOR NUM IN 1..5 LOOP
                SELECT *
                INTO RANKING, NAME, H_DATE
                FROM (SELECT ROWNUM AS RNUM, E. * FROM (SELECT EMP_NAME, HIRE_DATE FROM EMPLOYEE ORDER BY HIRE_DATE)E)
                WHERE RNUM = NUM;
                DBMS_OUTPUT.PUT_LINE('랭킹 : ' || RANKING || ' / 이름 : '|| NAME || ' / 입사일 : ' || H_DATE);
            END LOOP;
    END CASE;
END;
/


DECLARE
    USERINFO    EMPLOYEE%ROWTYPE;
    NUM NUMBER := 0;
BEGIN
    LOOP
        SELECT *
        INTO USERINFO
        FROM EMPLOYEE
        WHERE EMP_ID = 200 + NUM;
            DBMS_OUTPUT.PUT_LINE('이름 : ' || USERINFO.EMP_NAME);
        NUM := NUM + 1;
    END LOOP;
EXCEPTION
    WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE ('데이터를 조회할 수 없습니다.');
END;
/



SELECT * FROM EMPLOYEE;

CREATE TABLE TEST_MEMBER(
    MEMBER_ID       VARCHAR2(20)    PRIMARY KEY,
    MEMBER_NAME     VARCHAR2(20)    NOT NULL,
    MEMBER_AGE      NUMBER
);

CREATE TABLE REF_TEST_MEMBER(
    NUM         NUMBER          PRIMARY KEY,
    MEMBER_ID   VARCHAR2(10)    REFERENCES TEST_MEMBER(MEMBER_ID)
);

CREATE SEQUENCE REF_SEQ;
INSERT INTO TEST_MEMBER VALUES ('user01', '유저1', 20);
INSERT INTO TEST_MEMBER VALUES ('user02', '유저2', 21);
INSERT INTO TEST_MEMBER VALUES ('user03', '유저3', 22);
INSERT INTO TEST_MEMBER VALUES ('user04', '유저4', 23);

INSERT INTO REF_TEST_MEMBER VALUES (REF_SEQ.NEXTVAL, 'user03');

SELECT * FROM TEST_MEMBER;
SELECT * FROM REF_TEST_MEMBER;
COMMIT;

DELETE FROM REF_TEST_MEMBER WHERE MEMBER_ID = 'user03';
DELETE FROM TEST_MEMBER WHERE MEMBER_ID = 'user03';




CREATE OR REPLACE PROCEDURE DEL_TEST_MEMBER(ID TEST_MEMBER.MEMBER_ID%TYPE)
-- CREATE OR REPLACE PROCEDURE DEL_TEST_MEMBER(ID VARCHAR2)  -- VARCHAR2(길이) -> 길이 입력안하고 그대로 사용함
IS

BEGIN
    DELETE FROM REF_TEST_MEMBER WHERE MEMBER_ID = ID;
    DELETE FROM TEST_MEMBER WHERE MEMBER_ID = ID;
END;
/

EXEC DEL_TEST_MEMBER('user01');

CREATE OR REPLACE PROCEDURE DEL_TEST_MEMBER(NAME VARCHAR2)
IS
    ID TEST_MEMBER.MEMBER_ID%TYPE;
BEGIN
    SELECT MEMBER_ID
    INTO ID
    FROM TEST_MEMBER
    WHERE MEMBER_NAME = NAME;
    
    DELETE FROM REF_TEST_MEMBER WHERE MEMBER_ID = ID;
    DELETE FROM TEST_MEMBER WHERE MEMBER_ID = ID;
END;
/

EXEC DEL_TEST_MEMBER('유저2');




SELECT EMP_NAME, SALARY, BONUS, (SALARY + (SALARY * NVL(BONUS, 0))) * 12 연봉 FROM EMPLOYEE;
SELECT EMP_NAME, SALARY, BONUS, YEAR_SALARY(SALARY, NVL(BONUS, 0)) 연봉 FROM EMPLOYEE;
SELECT EMP_NAME, SALARY, BONUS, YEAR_SAL(EMP_ID) 연봉 FROM EMPLOYEE;

CREATE OR REPLACE FUNCTION YEAR_SALARY(SAL NUMBER, BO NUMBER)
RETURN NUMBER
IS
    CALC_SAL NUMBER;
BEGIN
    CALC_SAL := (SAL + (SAL * BO)) * 12;
    RETURN CALC_SAL;
END;
/


CREATE OR REPLACE FUNCTION YEAR_SAL(ID NUMBER)
RETURN NUMBER
IS
    SAL      NUMBER;
    BO       NUMBER;
    CALC_SAL NUMBER;
BEGIN
    SELECT SALARY, NVL(BONUS, 0)
    INTO SAL, BO
    FROM EMPLOYEE WHERE EMP_ID = ID;
    CALC_SAL := (SAL + (SAL * BO)) * 12;
    RETURN CALC_SAL;
END;
/



-- 쇼핑몰 판매 상품
CREATE TABLE PRODUCT(
    PCODE       NUMBER          PRIMARY KEY,    --  상품번호 / 상품코드
    PNAME       VARCHAR2(30),                   --  상품이름
    BRAND       VARCHAR2(30),                   --  제조회사
    PRICE       NUMBER,                         --  가격
    STOCK       NUMBER                          --  수량
);

CREATE SEQUENCE P_SEQ;   --  상품번호로 사용할 시퀀스


--  상품 입출력 테이블
CREATE TABLE PRO_INOUT(
    NO      NUMBER      PRIMARY KEY,                        --  입출고 관리번호
    PCODE   NUMBER      REFERENCES PRODUCT(PCODE),          --  상품번호
    PDATE   DATE,                                           --  입고 / 출고 날짜
    AMONUT  NUMBER,                                         --  입고 / 출고 수량
    STATUS  CHAR(6)     CHECK(STATUS IN('입고', '출고'))    --  입고 / 출고 구분
);

CREATE SEQUENCE IO_SEQ;     --  입/출고 번호 관리용 시퀀스     

INSERT INTO PRODUCT VALUES (P_SEQ.NEXTVAL, '에어팟프로', '애플', 240000, 0);
INSERT INTO PRODUCT VALUES (P_SEQ.NEXTVAL, '갤럭시버즈', '삼성', 250000, 0);

SELECT * FROM PRODUCT;
SELECT * FROM PRO_INOUT;

INSERT INTO PRO_INOUT VALUES(IO_SEQ.NEXTVAL, 1, SYSDATE, 10, '입고');
INSERT INTO PRO_INOUT VALUES(IO_SEQ.NEXTVAL, 2, SYSDATE, 20, '입고');
INSERT INTO PRO_INOUT VALUES(IO_SEQ.NEXTVAL, 1, SYSDATE, 1, '출고');
UPDATE PRODUCT SET STOCK = 10 WHERE PCODE = 1;
UPDATE PRODUCT SET STOCK = 19 WHERE PCODE = 2;


-- 제품명, 수량, 입고 / 출고         -> 프로시져 
-- 1) 제품명을 이용해서 제품번호 조회
-- 2) 조회된 제품번호로 PRO_INOUT 테이블에 INSERT
-- 3) 조회된 제품번호로 PRODUCT 테이블 수량 변경


CREATE OR REPLACE PROCEDURE IN_OUT(NAME VARCHAR2, AMO NUMBER, STATUS VARCHAR2)
IS
    P_CODE NUMBER;
    
BEGIN
    SELECT PCODE
    INTO P_CODE
    FROM PRODUCT
    WHERE PNAME = NAME;
    
    INSERT INTO PRO_INOUT VALUES (IO_SEQ.NEXTVAL, P_CODE, SYSDATE, AMO, STATUS);
    CASE STATUS
        WHEN '입고' THEN UPDATE PRODUCT SET STOCK = STOCK + AMO WHERE PCODE = P_CODE;
        WHEN '출고' THEN UPDATE PRODUCT SET STOCK = STOCK - AMO WHERE PCODE = P_CODE;
    END CASE;
END;
/

EXEC IN_OUT('에어팟프로', 15, '입고');
EXEC IN_OUT('갤럭시버즈', 7, '출고');



























-- UNION : 두 조회결과를 합침(중복된 데이터 제거, 첫번째 컬럼 오름차순으로 정렬)
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

-- UNION ALL : 두 조회결과를 합침 (중복된 데이터 제거하지 않음, 정렬X)
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;


-- INTERSECT : 두 조회결과 중 중복된 데이터만 출력
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;


-- MINUS : 두 조회결과 중 선행 조회결과에서 후행 조회결과와 겹치지 않는 부분만 출력
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;


-- 서브쿼리 기본예제
-- 전 직원의 평균 급여보다 많은 급여를 받고 있는 직원의 사번, 이름, 직급코드, 급여를 조회

-- 1. 전직원의 평균 급여
SELECT AVG(SALARY) FROM EMPLOYEE;
-- 2. 평균값을 이용해서 더 많이 받는 직원 정보 조회
SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3040000;
-- 단일행 서브쿼리 사용 (서브쿼리의 수행 결과가 1행 1열 -> 단일값 1개인 경우)
SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE)
;

-- 1. 윤은해와 급여가 같은 사원들의 사번, 이름, 급여 출력
-- 단, 윤은해는 출력 X
    -- 1) 윤은해 급여 조회 
SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME = '윤은해';
    -- 2) 급여가 같은 사원들 사번, 이름, 급여 출력
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE
EMP_NAME != '윤은해' AND SALARY = (SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME = '윤은해')
;

-- 2. EMPLOYEE 테이블에서 급여가 가장 많은 사람과, 가장 적은 사람의 사번, 사원명, 급여
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE 
WHERE
SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE) OR SALARY = (SELECT MIN(SALARY) FROM EMPLOYEE)
-- SALARY IN ((SELECT MAX(SALARY) FROM EMPLOYEE), (SELECT MIN(SALARY) FROM EMPLOYEE))
;

-- 3. D1, D2 부서에 근무하는 사원들 중 급여가 D5 부서의 평균 급여보다 많은 사람들의 부서번호, 사원번호, 사원명, 월급
SELECT DEPT_CODE, EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE 
DEPT_CODE IN ('D1', 'D2') AND SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE = 'D5')
;



-- 다중행 서브쿼리 : 서브쿼리 조회 결과가 행이 여러개일때 (열은 1개)
-- 사용 가능한 연산자 : IN / NOT IN, ANY, ALL, EXIST

-- 송중기, 박나라가 속한 부서에 속한 사원들 정보(이름, 부서코드, 급여)
SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME IN ('송중기', '박나라');

SELECT EMP_NAME, DEPT_CODE, SALARY FROM EMPLOYEE
WHERE
DEPT_CODE IN (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME IN ('송중기', '박나라'))
;


-- ANY
    -- X > ANY : 내부에 어떠한 값보다 크기만하면 참 -> 최소값보다 크면 참
SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY > 2000000 OR SALARY > 3000000;
SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY > ANY(2000000, 3000000);
    -- X < ANY : 내부에 어떠한 값보다 작기만 하면 참 -> 최대값보다 작으면 참
SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY < ANY(2000000, 3000000);
    -- X = ANY : 내부의 값 중 하나 이상의 값과 일치하면 참 -> IN 동일
    
- D1 또는 D5 부서코드를 가지고 있는 사원들의 급여 중 가장 높은 급여보다 작은 사원들의 이름, 급여, 부서코드
    SELECT SALARY FROM EMPLOYEE WHERE DEPT_CODE IN ('D1', 'D5');
    SELECT EMP_NAME, SALARY, DEPT_CODE FROM EMPLOYEE WHERE SALARY > ANY(SELECT SALARY FROM EMPLOYEE WHERE DEPT_CODE IN ('D1', 'D5'));
    
-- ALL
    -- X > ALL : 최대값보다 크면
    SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY > ALL(2000000, 3000000, 4000000, 5000000);
    SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY > 2000000 AND SALARY > 3000000 AND SALARY > 4000000 AND SALARY > 5000000;
    -- X < ALL : 최소값보다 작으면
    SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY < ALL(2000000, 3000000, 4000000, 5000000);
    SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY < 2000000 AND SALARY < 3000000 AND SALARY < 4000000 AND SALARY < 5000000;
    -- X = ALL : 서브쿼리 조회결과가 1개면 상관없으나 여러개면 에러
    SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY = ALL(2000000, 3000000);
    SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY = 2000000 AND SALARY = 3000000;
    
-- 다중열 서브쿼리 : 서브쿼리 조회 결과가 1행이며 열이 여러개인 경우
-- 퇴사한 여직원이 한명있습니다. 그 직원과 같은 부서, 같은 직급인 직원의 이름, 직급, 부서 조회
SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE ENT_YN = 'Y';

SELECT EMP_NAME, JOB_CODE, DEPT_CODE FROM EMPLOYEE
WHERE DEPT_CODE = 'D8' AND JOB_CODE = 'J6';

SELECT EMP_NAME, JOB_CODE, DEPT_CODE FROM EMPLOYEE
WHERE (DEPT_CODE, JOB_CODE) IN (SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE ENT_YN = 'Y');


-- 다중행 다중열 서브쿼리 : 서브쿼리 조회 결과 컬럼수와 행의 개수가 여러개일때
-- 직급별로 최소 급여를 받는 직원의 이름, 사번, 부서코드, 입사일 ,급여
-- 1) 직급별 최소 급여
SELECT JOB_CODE, MIN(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE;

SELECT EMP_NAME, EMP_ID, DEPT_CODE, HIRE_DATE, SALARY
FROM EMPLOYEE
WHERE (JOB_CODE, SALARY) IN (SELECT JOB_CODE, MIN(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE);

SELECT EMP_NAME, EMP_ID, DEPT_CODE, HIRE_DATE, SALARY
FROM EMPLOYEE
WHERE (JOB_CODE = 'J2' AND SALARY = 3700000) OR (JOB_CODE = 'J7' AND SALARY = 13800000) OR (JOB_CODE = 'J3' AND SALARY = 3400000);




-- 상호연관 서브쿼리 -> JOIN문 대체가능
-- 인사관리부. 회계관리부, 마케팅부에 근무하는 직원의 이름, 부서코드, 급여 조회
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE DEPT_TITLE IN ('인사관리부', '회계관리부', '마케팅부');

-- 상호연관쿼리를 사용하지않고 다중행 서브쿼리로 처리
SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_TITLE IN ('인사관리부', '회계관리부', '마케팅부');

SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE IN (SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_TITLE IN ('인사관리부', '회계관리부', '마케팅부'));

-- 상호연관쿼리 ( EXISTS : 조회결과가 있으면 TRUE, 없으면 FALSE)
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE E
WHERE EXISTS
(SELECT 1 FROM DEPARTMENT D WHERE D.DEPT_TITLE IN ('인사관리부', '회계관리부', '마케팅부') AND D.DEPT_ID =  E.DEPT_CODE);


-- 관리자가 있는 사원들 중 관리자 사번이 EMPLOYEE 테이블에 존재하는 직원의 사번, 이름, 부서코드, 관리자 사번
SELECT EMP_ID, EMP_NAME, DEPT_CODE, MANAGER_ID
FROM EMPLOYEE
WHERE
MANAGER_ID IS NOT NULL;
;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, MANAGER_ID
FROM EMPLOYEE E1
WHERE EXISTS
(SELECT 1 FROM EMPLOYEE E2 WHERE E2.EMP_ID = E1.MANAGER_ID)
;

SELECT EMP_NAME, DEPT_CODE FROM EMPLOYEE;
SELECT EMP_NAME, DEPT_CODE FROM EMPLOYEE WHERE DEPT_CODE IN ('D1', 'D2', 'D9');
SELECT EMP_NAME, NVL(BONUS, 0) FROM EMPLOYEE;

SELECT EMP_NAME, BONUS
FROM EMPLOYEE E1
WHERE EXISTS
(SELECT EMP_NAME FROM EMPLOYEE E2 WHERE NVL(E1.BONUS, 0) >= 0.3);

SELECT EMP_NAME, BONUS
FROM EMPLOYEE E1
WHERE EXISTS
(SELECT EMP_NAME FROM EMPLOYEE E2 WHERE NVL(E2.BONUS, 0) >= 0.3);



-- 스칼라서브쿼리 : 상호연관쿼리이면서 결과값이 단일행 서브쿼리
-- 1) SELECT 절 사용
-- 모든 사원의 사번, 이름, 관리자사번, 관리자명 (없는경우 없음)
SELECT E1.EMP_ID, E1.EMP_NAME, E1.MANAGER_ID, 
NVL((SELECT E2.EMP_NAME FROM EMPLOYEE E2 WHERE E2.EMP_ID = E1.MANAGER_ID), '없음') 관리자명
FROM EMPLOYEE E1;

SELECT E2.EMP_NAME FROM EMPLOYEE E2 WHERE E2.EMP_ID = 200;

-- 사원명, 부서코드, 소속 부서별 평균급여를 스칼라서브쿼리를 이용해서 출력
SELECT E1.EMP_NAME, E1.DEPT_CODE,
FLOOR((SELECT AVG(SALARY) FROM EMPLOYEE E2 WHERE E2.DEPT_CODE = E1.DEPT_CODE))평균급여
FROM EMPLOYEE E1;



-- 스칼라 서브쿼리 WHERE
-- 자신이 속한 직급의 평균 급여보다 많이 받는 직원의 이름, 직급코드, 급여
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE E1
WHERE SALARY >= (SELECT AVG(SALARY) FROM EMPLOYEE E2 WHERE E2.JOB_CODE = E1.JOB_CODE);

-- 스칼라 서브쿼리 ORDER BY 절
-- 이름, 부서코드 출력 정렬은 부서명
SELECT EMP_NAME , DEPT_CODE FROM EMPLOYEE ORDER BY (SELECT DEPT_TITLE FROM DEPARTMENT WHERE DEPT_CODE = DEPT_ID);

SELECT EMP_NAME , DEPT_CODE, (SELECT DEPT_TITLE FROM DEPARTMENT WHERE DEPT_CODE = DEPT_ID) 
FROM EMPLOYEE
ORDER BY (SELECT DEPT_TITLE FROM DEPARTMENT WHERE DEPT_CODE = DEPT_ID);



-- 스칼라 서브쿼리 FROM절에 사용 -> 인라인 뷰
SELECT * FROM
(SELECT EMP_NAME, EMAIL, PHONE, SALARY FROM EMPLOYEE);

-- TOP-N 분석 : 상위 몇개 조회 -> 연봉 많이받는 직원 TOP 5
SELECT EMP_NAME, SALARY FROM EMPLOYEE ORDER BY SALARY DESC;

SELECT * FROM EMPLOYEE WHERE SALARY >= 3700000; -- 이렇게 하면 내용 변동 시 문제발생

SELECT ROWNUM, E.* FROM
(SELECT EMP_NAME, SALARY FROM EMPLOYEE ORDER BY SALARY DESC) E
WHERE
ROWNUM < 6
;

SELECT EMP_NAME, SALARY, RANK() OVER(ORDER BY SALARY DESC) 순위 FROM EMPLOYEE;
SELECT EMP_NAME, SALARY, DENSE_RANK OVER(ORDER BY SALARY DESC) 순위 FROM EMPLOYEE;
SELECT EMP_NAME, SALARY, ROW_NUMBER() OVER(ORDER BY SALARY DESC) 순위 FROM EMPLOYEE;


